(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  };
})(typeof global === "undefined" ? self : global);(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

/**
 * MUI Angular main module
 * @module angular/main
 */

(function (win) {
  // return if library has been loaded already
  if (win._muiAngularLoaded) return;else win._muiAngularLoaded = true;

  win.angular.module('mui', [require('src/angular/appbar'), require('src/angular/button'), require('src/angular/caret'), require('src/angular/container'), require('src/angular/divider'), require('src/angular/dropdown'), require('src/angular/dropdown-item'), require('src/angular/panel'), require('src/angular/input'), require('src/angular/row'), require('src/angular/col'), require('src/angular/tabs'), require('src/angular/radio'), require('src/angular/checkbox'), require('src/angular/option'), require('src/angular/select'), require('src/angular/form')]);
})(window);

},{"src/angular/appbar":2,"src/angular/button":3,"src/angular/caret":4,"src/angular/checkbox":5,"src/angular/col":6,"src/angular/container":7,"src/angular/divider":8,"src/angular/dropdown":10,"src/angular/dropdown-item":9,"src/angular/form":11,"src/angular/input":12,"src/angular/option":13,"src/angular/panel":14,"src/angular/radio":15,"src/angular/row":16,"src/angular/select":17,"src/angular/tabs":18}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.appbar'; /**
                                * MUI Angular Appbar Component
                                * @module angular/appbar
                                */

_angular2.default.module(moduleName, []).directive('muiAppbar', function () {
  return {
    restrict: 'AE',
    transclude: true,
    replace: true,
    template: '<div class="mui-appbar"></div>',
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);

var _util = require('../js/lib/util');

var util = babelHelpers.interopRequireWildcard(_util);


var moduleName = 'mui.button',
    supportsTouch = 'ontouchstart' in document.documentElement,
    mouseDownEvents = supportsTouch ? 'touchstart' : 'mousedown',
    mouseUpEvents = supportsTouch ? 'touchend' : 'mouseup mouseleave'; /**
                                                                        * MUI Angular Button Component
                                                                        * @module angular/button
                                                                        */

_angular2.default.module(moduleName, []).directive('muiButton', function () {
  return {
    restrict: 'AE',
    replace: true,
    template: '<button class="mui-btn" mui-ripple>' + '<ng-transclude></ng-transclude>' + '<span class="mui-btn__ripple-container">' + '<span class="mui-ripple"></span>' + '</span>' + '</button>',
    transclude: true,
    link: function link(scope, element, attrs) {
      var isUndef = _angular2.default.isUndefined,
          el = element[0];

      // disable MUI js
      el._muiDropdown = true;
      el._muiRipple = true;

      // handle disabled attribute
      if (!isUndef(attrs.disabled) && isUndef(attrs.ngDisabled)) {
        element.prop('disabled', true);
      }

      // set button styles        
      _angular2.default.forEach(['variant', 'color', 'size'], function (attrName) {
        var attrVal = attrs[attrName];
        if (attrVal) element.addClass('mui-btn--' + attrVal);
      });
    }
  };
}).directive('muiRipple', ['$timeout', function ($timeout) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      var buttonEl = element[0];

      // cache reference to ripple element
      buttonEl._rippleEl = buttonEl.querySelector('.mui-ripple');

      // add mousedown and mouseup event ripple effect handlers
      element.on(mouseDownEvents, mouseDownHandler);
    }
  };
}]);

/**
 * MouseDown event handler.
 * @param {Event} ev - The DOM event
 */
function mouseDownHandler(ev) {
  var buttonEl = this,
      rippleEl = buttonEl._rippleEl;

  // exit if disabled
  if (buttonEl.disabled) return;

  // add mouseup handler on first-click
  if (!rippleEl._init) {
    jqLite.on(buttonEl, mouseUpEvents, mouseUpHandler);
    rippleEl._init = true;
  }

  // get (x, y) position of click
  var offset = jqLite.offset(buttonEl),
      clickEv = ev.type === 'touchstart' ? ev.touches[0] : ev,
      radius,
      diameter;

  // calculate radius
  radius = Math.sqrt(offset.width * offset.width + offset.height * offset.height);

  diameter = radius * 2 + 'px';

  // set position and dimensions
  jqLite.css(rippleEl, {
    width: diameter,
    height: diameter,
    top: Math.round(clickEv.pageY - offset.top - radius) + 'px',
    left: Math.round(clickEv.pageX - offset.left - radius) + 'px'
  });

  jqLite.removeClass(rippleEl, 'mui--is-animating');
  jqLite.addClass(rippleEl, 'mui--is-visible');

  // start animation
  util.requestAnimationFrame(function () {
    jqLite.addClass(rippleEl, 'mui--is-animating');
  });
}

/**
 * MouseUp event handler.
 * @param {Event} ev - The DOM event
 */
function mouseUpHandler(ev) {
  // get ripple element
  var rippleEl = this._rippleEl;

  // allow a repaint to occur before removing class so animation shows for
  // tap events
  util.requestAnimationFrame(function () {
    jqLite.removeClass(rippleEl, 'mui--is-visible');
  });
}

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/jqLite":21,"../js/lib/util":22,"angular":"angular"}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.caret'; /**
                               * MUI Angular Caret Component
                               * @module angular/caret
                               */

_angular2.default.module(moduleName, []).directive('muiCaret', function () {
  return {
    restrict: 'AE',
    replace: true,
    template: '<span class="mui-caret"></span>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.checkbox'; /**
                                  * MUI Angular Checkbox Component
                                  * @module angular/checkox
                                  */

_angular2.default.module(moduleName, []).directive('muiCheckbox', ['$parse', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: {
      label: '@',
      name: '@',
      value: '@',
      ngChecked: '=',
      ngDisabled: '=',
      ngModel: '='
    },
    template: function template(tElement, tAttrs) {
      var isUndef = _angular2.default.isUndefined,
          html = '';

      html += '<div class="mui-checkbox"><label><input type="checkbox" ';

      // input attributes
      html += 'name={{name}} ';
      html += 'value={{value}} ';
      html += 'ng-disabled="ngDisabled" ';

      // handle ngChecked and ngModel
      if (!isUndef(tAttrs.ngChecked)) html += 'ng-checked="ngChecked" ';
      if (!isUndef(tAttrs.ngModel)) html += 'ng-model="ngModel" ';

      html += '>{{label}}</label></div>';

      return html;
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.col'; /**
                             * MUI Angular Col (Grid) Component
                             * @module angular/col
                             */

_angular2.default.module(moduleName, []).directive('muiCol', function () {
  return {
    restrict: 'AE',
    scope: true,
    replace: true,
    template: '<div></div>',
    transclude: true,
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });

      // iterate through breakpoints
      var breakpoints = {
        'xs': 'mui-col-xs-',
        'sm': 'mui-col-sm-',
        'md': 'mui-col-md-',
        'lg': 'mui-col-lg-',
        'xl': 'mui-col-xl-',
        'xs-offset': 'mui-col-xs-offset-',
        'sm-offset': 'mui-col-sm-offset-',
        'md-offset': 'mui-col-md-offset-',
        'lg-offset': 'mui-col-lg-offset-',
        'xl-offset': 'mui-col-xl-offset-'
      };

      _angular2.default.forEach(breakpoints, function (value, key) {
        var attrVal = attrs[attrs.$normalize(key)];
        if (attrVal) element.addClass(value + attrVal);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.container'; /**
                                   * MUI Angular Container Component
                                   * @module angular/container
                                   */

_angular2.default.module(moduleName, []).directive('muiContainer', function () {
  return {
    restrict: 'AE',
    template: '<div class="mui-container"></div>',
    transclude: true,
    scope: true,
    replace: true,
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });

      // handle fluid containers
      if (!_angular2.default.isUndefined(attrs.fluid)) {
        element.removeClass('mui-container').addClass('mui-container-fluid');
      }
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.divider'; /**
                                 * MUI Angular Divider Component
                                 * @module angular/divider
                                 */

_angular2.default.module(moduleName, []).directive('muiDivider', function () {
  return {
    restrict: 'AE',
    replace: true,
    compile: function compile(tElement, tAttrs) {
      tElement.addClass('mui-divider');
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.dropdown-item'; /**
                                       * MUI Angular DropdownItem Component
                                       * @module angular/dropdown-item
                                       */

_angular2.default.module(moduleName, []).directive('muiDropdownItem', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: {
      link: '@'
    },
    transclude: true,
    template: '<li><a href="{{link}}" ng-transclude></a></li>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.dropdown'; /**
                                  * MUI Angular Dropdown Component
                                  * @module angular/dropdown
                                  */

_angular2.default.module(moduleName, []).directive('muiDropdown', ['$timeout', '$compile', function ($timeout, $compile) {
  return {
    restrict: 'AE',
    transclude: true,
    replace: true,
    scope: {
      variant: '@',
      color: '@',
      size: '@',
      open: '=?',
      ngDisabled: '='
    },
    template: '<div class="mui-dropdown">' + '<mui-button ' + 'variant="{{variant}}" ' + 'color="{{color}}" ' + 'size="{{size}}" ' + 'ng-click="onClick($event);" ' + '></mui-button>' + '<ul class="mui-dropdown__menu" ng-transclude></ul>' + '</div>',
    link: function link(scope, element, attrs) {
      var dropdownClass = 'mui-dropdown',
          menuClass = 'mui-dropdown__menu',
          openClass = 'mui--is-open',
          rightClass = 'mui-dropdown__menu--right',
          isUndef = _angular2.default.isUndefined,
          menuEl,
          buttonEl;

      // save references
      menuEl = _angular2.default.element(element[0].querySelector('.' + menuClass));
      buttonEl = _angular2.default.element(element[0].querySelector('.mui-btn'));

      menuEl.css('margin-top', '-3px');

      // handle is-open
      if (!isUndef(attrs.open)) scope.open = true;

      // handle disabled
      if (!isUndef(attrs.disabled)) {
        buttonEl.attr('disabled', true);
      }

      // handle right-align
      if (!isUndef(attrs.rightAlign)) menuEl.addClass(rightClass);

      // handle no-caret
      if (!isUndef(attrs.noCaret)) buttonEl.html(attrs.label);else buttonEl.html(attrs.label + ' <mui-caret></mui-caret>');

      function closeDropdownFn() {
        scope.open = false;
        scope.$apply();
      }

      function handleKeyDownFn(ev) {
        // close dropdown on escape key
        var key = ev.key;
        if (key === 'Escape' || key === 'Esc') closeDropdownFn();
      }

      // handle menu open
      scope.$watch('open', function (newValue) {
        var doc = document;
        if (newValue === true) {
          menuEl.addClass(openClass);
          doc.addEventListener('click', closeDropdownFn);
          doc.addEventListener('keydown', handleKeyDownFn);
        } else if (newValue === false) {
          menuEl.removeClass(openClass);
          doc.removeEventListener('click', closeDropdownFn);
          doc.removeEventListener('keydown', handleKeyDownFn);
        }
      });

      // click handler
      scope.onClick = function ($event) {
        // exit if disabled
        if (scope.disabled) return;

        // prevent form submission
        $event.preventDefault();
        $event.stopPropagation();

        // toggle open 
        if (scope.open) scope.open = false;else scope.open = true;
      };
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.form'; /**
                              * MUI Angular Form Directive
                              * @module angular/form
                              */

_angular2.default.module(moduleName, []).directive('muiForm', function () {
  return {
    restrict: 'AE',
    template: '<form class="mui-form"></form>',
    transclude: true,
    scope: true,
    replace: true,
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });

      // handle inline forms
      if (!_angular2.default.isUndefined(attrs.inline)) {
        element.addClass('mui-form--inline');
      }
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.input';

/**
 * Build directive function.
 * @param {Boolean} isTextArea
 */
/**
 * MUI Angular Input and Textarea Components
 * @module angular/input
 */

function inputFactory(isTextArea) {
  var scopeArgs, template, ngClassStr, attrs;

  // defaults
  scopeArgs = {
    floatLabel: '@',
    hint: '@',
    label: '@',
    name: '@',
    ngDisabled: '=',
    ngMaxlength: '@',
    ngMinlength: '@',
    ngModel: '='
  };

  template = '<div class="mui-textfield">';

  ngClassStr = '{' + ["'mui--is-touched': inputCtrl.$touched", // hasn't lost focus yet
  "'mui--is-untouched': inputCtrl.$untouched", "'mui--is-pristine': inputCtrl.$pristine", // user hasn't interacted yet
  "'mui--is-dirty': inputCtrl.$dirty", "'mui--is-empty': inputCtrl.$isEmpty(inputCtrl.$viewValue)", "'mui--is-not-empty': !inputCtrl.$isEmpty(inputCtrl.$viewValue)", "'mui--is-invalid': inputCtrl.$invalid"].join(',') + '}';

  attrs = ['name={{name}}', 'placeholder={{hint}}', 'ng-class="' + ngClassStr + '"', 'ng-disabled="ngDisabled"', 'ng-maxlength={{ngMaxlength}}', 'ng-minlength={{ngMinlength}}', 'ng-model="ngModel"'];

  // element-specific
  if (!isTextArea) {
    scopeArgs.type = '@';
    attrs.push('type={{type}}');
    template += '<input ' + attrs.join(' ') + '>';
  } else {
    scopeArgs.rows = '@';
    attrs.push('rows={{rows}}');
    template += '<textarea ' + attrs.join(' ') + '></textarea>';
  }

  // update template
  template += '<label tabindex="-1">{{label}}</label></div>';

  // directive function
  return ['$timeout', function ($timeout) {
    return {
      restrict: 'AE',
      require: ['ngModel'],
      scope: scopeArgs,
      replace: true,
      template: template,
      link: function link(scope, element, attrs, controllers) {
        var inputEl = element.find(isTextArea ? 'textarea' : 'input'),
            labelEl = element.find('label'),
            ngModelCtrl = controllers[0],
            formCtrl = controllers[1],
            isUndef = _angular2.default.isUndefined,
            el = inputEl[0];

        // add inputCrl to scope
        scope.inputCtrl = inputEl.controller('ngModel');

        // disable MUI js
        if (el) el._muiTextfield = true;

        // remove attributes from wrapper
        element.removeAttr('ng-change');
        element.removeAttr('ng-model');
        element.removeAttr('ng-minlength');
        element.removeAttr('ng-maxlength');

        // scope defaults
        if (!isTextArea) scope.type = scope.type || 'text';else scope.rows = scope.rows || 2;

        // autofocus
        if (!isUndef(attrs.autofocus)) inputEl[0].focus();

        // required
        if (!isUndef(attrs.required)) inputEl.prop('required', true);

        // invalid
        if (!isUndef(attrs.invalid)) inputEl.addClass('mui--is-invalid');

        // float-label
        if (!isUndef(scope.floatLabel)) {
          element.addClass('mui-textfield--float-label');

          $timeout(function () {
            labelEl.css({
              'transition': '.15s ease-out',
              '-webkit-transition': '.15s ease-out',
              '-moz-transition': '.15s ease-out',
              '-o-transition': '.15s ease-out',
              '-ms-transition': '.15s ease-out'
            });
          }, 150);
        }

        // handle changes
        scope.onChange = function () {
          // trigger ng-change on parent
          if (ngModelCtrl) ngModelCtrl.$setViewValue(scope.ngModel);
        };
      }
    };
  }];
}

_angular2.default.module(moduleName, []).directive('muiInput', inputFactory(false)).directive('muiTextarea', inputFactory(true));

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _forms = require('../js/lib/forms');

var formlib = babelHelpers.interopRequireWildcard(_forms);

var _util = require('../js/lib/util');

var util = babelHelpers.interopRequireWildcard(_util);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);
/**
 * MUI Angular Select Component
 * @module angular/select
 */

var moduleName = 'mui.option';

_angular2.default.module(moduleName, []).directive('muiOption', function () {
  return {
    restrict: 'AE',
    replace: true,
    //require: '^muiSelect',
    scope: {
      label: '@',
      value: '@',
      ngDisabled: '='
    },
    template: '<option>{{label}}</option>',
    link: function link(scope, element, attrs, controller) {
      /*
      // register
      controller.addMenuItem({
        label: attrs.label,
        value: attrs.value,
        disabled: scope.ngDisabled,
        hidden: attrs.hidden
      });
       // destroy hook
      scope.$on('$destroy', function() {
        controller.removeMenuItem(attrs.value);
      });
      */
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/forms":20,"../js/lib/jqLite":21,"../js/lib/util":22,"angular":"angular"}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.panel'; /**
                               * MUI Angular Panel Component
                               * @module angular/panel
                               */

_angular2.default.module(moduleName, []).directive('muiPanel', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: true,
    template: '<div class="mui-panel"></div>',
    transclude: true,
    link: function link(scope, element, attr, controller, transcludeFn) {
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.radio'; /**
                               * MUI Angular Radio Component
                               * @module angular/radio
                               */

_angular2.default.module(moduleName, []).directive('muiRadio', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: {
      label: '@',
      name: '@',
      value: '@',
      ngChecked: '=',
      ngDisabled: '=',
      ngModel: '='
    },
    template: function template(tElement, tAttrs) {
      var isUndef = _angular2.default.isUndefined,
          html = '';

      html += '<div class="mui-radio"><label><input type="radio" ';

      // input attributes
      html += 'name={{name}} ';
      html += 'value={{value}} ';
      html += 'ng-disabled="ngDisabled" ';

      // handle ngChecked and ngModel
      if (!isUndef(tAttrs.ngChecked)) html += 'ng-checked="ngChecked" ';
      if (!isUndef(tAttrs.ngModel)) html += 'ng-model="ngModel" ';

      html += '>{{label}}</label></div>';

      return html;
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.row'; /**
                             * MUI Angular Grid/Row Module
                             * @module angular/row.js
                             */

_angular2.default.module('mui.row', []).directive('muiRow', function () {
  return {
    restrict: 'AE',
    scope: true,
    replace: true,
    template: '<div class="mui-row"></div>',
    transclude: true,
    link: function link(scope, element, attr, controller, transcludeFn) {
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"angular"}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _forms = require('../js/lib/forms');

var formlib = babelHelpers.interopRequireWildcard(_forms);

var _util = require('../js/lib/util');

var util = babelHelpers.interopRequireWildcard(_util);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);
/**
 * MUI Angular Select Component
 * @module angular/select
 */

var moduleName = 'mui.select';

_angular2.default.module(moduleName, []).directive('muiSelect', ['$timeout', function ($timeout) {
  return {
    restrict: 'AE',
    require: ['ngModel'],
    scope: {
      label: '@',
      name: '@',
      placeholder: '@',
      ngDisabled: '=',
      ngModel: '=',
      ngRequired: '='
    },
    replace: true,
    transclude: true,
    template: '<div class="mui-select" ' + 'ng-blur="onWrapperBlurOrFocus($event)" ' + 'ng-click="onWrapperClick($event)" ' + 'ng-focus="onWrapperBlurOrFocus($event)" ' + 'ng-keydown="onWrapperKeydown($event)" ' + 'ng-keypress="onWrapperKeypress($event)">' + '<select ' + 'name="{{name}}" ' + 'ng-class=\'{"mui--text-placeholder": placeholder && ngModel == ""}\' ' + 'ng-disabled="ngDisabled" ' + 'ng-model="ngModel" ' + 'ng-mousedown="onInnerMousedown($event)" ' + 'ng-required="ngRequired" ' + '>' + '<option ng-if="placeholder" value="" placeholder>{{placeholder}}</option>' + '</select>' + '<label tabindex="-1">{{label}}</label>' + '<div ' + 'class="mui-select__menu"' + 'ng-if="!useDefault && isOpen">' + '<div ' + 'ng-click="chooseOption($event, option)" ' + 'ng-repeat="option in selectEl.children() track by $index" ' + 'ng-class=\'{"mui--is-selected": $index === menuIndex, "mui--text-placeholder": option.hasAttribute("placeholder"), "mui--is-disabled": option.disabled}\' ' + 'ng-disabled="option.disabled" ' + 'ng-hide="option.hidden" ' + '>{{option.innerText}}</div>' + '</div>' + '</div>',
    link: function link(scope, element, attrs, controller, transcludeFn) {
      var wrapperEl = element,
          selectEl = element.find('select'),
          isUndef = _angular2.default.isUndefined,
          origValue;

      // disable MUI js
      selectEl[0]._muiSelect = true;

      // init scope
      scope.selectEl = selectEl;
      scope.isOpen = false;
      scope.useDefault = 'ontouchstart' in document.documentElement ? true : false;
      scope.origTabIndex = selectEl[0].tabIndex;
      scope.menuIndex = 0;
      scope.q = '';
      scope.qTimeout = null;

      // handle `use-default` attribute
      if (!isUndef(attrs.useDefault)) scope.useDefault = true;

      // use tabIndex to make wrapper or inner focusable
      if (scope.useDefault === false) {
        wrapperEl.prop('tabIndex', '0');
        selectEl.prop('tabIndex', '-1');
      } else {
        wrapperEl.prop('tabIndex', '-1');
        selectEl.prop('tabIndex', '0');
      }

      // add <option> tags to <select>
      transcludeFn(function (clone) {
        selectEl.append(clone);
      });

      function dispatchChange(option) {
        selectEl[0].selectedIndex = option.index;

        if (option.value !== origValue) {
          scope.ngModel = option.value;

          // trigger change event
          $timeout(function () {
            util.dispatchEvent(selectEl[0], 'change', true, false);
          });
        }
      }

      /**
       * Handle blur and focus events on wrapper <div> element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperBlurOrFocus = function ($event) {
        // ignore events that bubbled up
        if (document.activeElement !== wrapperEl[0]) return;

        util.dispatchEvent(selectEl[0], $event.type, false, false);
      };

      /**
       * Handle click event on wrapper <div> element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperClick = function ($event) {
        // only left click, check default prevented and useDefault
        if ($event.button !== 0 || $event.defaultPrevented || scope.useDefault || selectEl[0].disabled) {
          return;
        }

        // focus wrapper
        wrapperEl[0].focus();

        // open custom menu
        scope.isOpen = true;
      };

      /**
       * Handle keydown event on wrapper element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperKeydown = function ($event) {
        // exit if preventDefault() was called or useDefault is true
        if ($event.defaultPrevented || scope.useDefault) return;

        var keyCode = $event.keyCode;

        if (scope.isOpen === false) {
          // spacebar, down, up
          if (keyCode === 32 || keyCode === 38 || keyCode === 40) {
            // prevent win scroll
            $event.preventDefault();

            // open menu
            scope.isOpen = true;
          }
        } else {
          // tab
          if (keyCode === 9) return scope.isOpen = false;

          // escape | up | down | enter
          if (keyCode === 27 || keyCode === 40 || keyCode === 38 || keyCode === 13) {
            $event.preventDefault();
          }

          var options = selectEl.children(),
              nextIndex = null,
              i;

          if (keyCode === 27) {
            // escape -> close
            scope.isOpen = false;
          } else if (keyCode === 40) {
            // down -> increment
            i = scope.menuIndex + 1;
            while (i < options.length) {
              // exit if option not disabled
              if (!options[i].disabled && !options[i].hidden) {
                nextIndex = i;
                break;
              }
              i += 1;
            }

            if (nextIndex !== null) scope.menuIndex = nextIndex;
          } else if (keyCode === 38) {
            // up -> decrement
            i = scope.menuIndex - 1;
            while (i > -1) {
              // exit if option not disabled
              if (!options[i].disabled && !options[i].hidden) {
                nextIndex = i;
                break;
              }
              i -= 1;
            }

            if (nextIndex !== null) scope.menuIndex = nextIndex;
          } else if (keyCode === 13) {
            // enter -> choose and close
            dispatchChange(options[scope.menuIndex]);
            scope.isOpen = false;
          }
        }
      };

      /**
       * Handle keypress event on wrapper element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperKeypress = function ($event) {
        // exit if preventDefault() was called or useDefault is true or
        // menu is closed
        if ($event.defaultPrevented || scope.useDefault || !scope.isOpen) {
          return;
        }

        // handle query timer
        clearTimeout(scope.qTimeout);
        scope.q += $event.key;
        scope.qTimeout = setTimeout(function () {
          scope.q = '';
        }, 600);

        // select first match alphabetically
        var prefixRegex = new RegExp('^' + scope.q, 'i'),
            options = selectEl.children(),
            m = options.length,
            option,
            i;

        for (i = 0; i < m; i++) {
          option = options[i];
          if (!option.hidden && !option.disabled && prefixRegex.test(option.innerText)) {
            scope.menuIndex = option.index;
            break;
          }
        }
      };

      /**
       * Handle mousedown event on Inner <select> element
       * @param {Event} $event - Angular event instance
       */
      scope.onInnerMousedown = function ($event) {
        // check flag
        if ($event.button !== 0 || scope.useDefault === true) return;

        // prevent built-in menu from opening
        $event.preventDefault();
      };

      /**
       * Choose option the user selected.
       * @param {Object} option - The option selected.
       */
      scope.chooseOption = function ($event, option) {
        // prevent bubbling
        $event.stopImmediatePropagation();

        // ignore disabled
        if (option.disabled) return;

        // dispatch change
        dispatchChange(option);

        // close menu
        scope.isOpen = false;
      };

      // function to close menu on window resize and document click
      function closeMenuFn() {
        scope.isOpen = false;

        // disable scroll lock
        util.disableScrollLock(true);

        // remove event handlers
        jqLite.off(document, 'click', closeMenuFn);
        jqLite.off(window, 'resize', closeMenuFn);

        scope.$digest();
      }

      /**
       * Open/Close custom select menu
       */
      scope.$watch('isOpen', function (isOpen, oldVal) {
        // ignore first call
        if (isOpen === oldVal) return;

        // exit if use-default is true
        if (scope.useDefault === true) return;

        if (isOpen === true) {
          // enable scroll lock
          util.enableScrollLock();

          // init menuIndex
          var menuEl = element.find('div'),
              value = scope.ngModel,
              options = selectEl.children(),
              m = options.length,
              i;

          origValue = scope.ngModel;
          scope.menuIndex = scope.menuIndex;

          $timeout(function () {
            // set position of custom menu
            var props = formlib.getMenuPositionalCSS(element[0], menuEl[0], scope.menuIndex);

            props.height = 'auto';
            menuEl.css(props);
            jqLite.scrollTop(menuEl[0], props.scrollTop);

            // attach event handlers
            jqLite.on(document, 'click', closeMenuFn);
            jqLite.on(window, 'resize', closeMenuFn);
          });
        } else {
          // focus select element
          selectEl[0].focus();

          // disable scroll lock
          util.disableScrollLock(true);

          // remove event handlers
          jqLite.off(document, 'click', closeMenuFn);
          jqLite.off(window, 'resize', closeMenuFn);
        }
      });

      /**
       * Scroll to menu items (if hidden)
       */
      scope.$watch('menuIndex', function (newVal, oldVal) {
        // skip initialization
        if (newVal === oldVal) return;

        // scroll menu after rendering is finished
        $timeout(function () {
          var itemEl = selectEl.children()[scope.menuIndex],
              itemRect = itemEl.getBoundingClientRect(),
              menuEl = itemEl.parentNode;

          if (itemRect.top < 0) {
            // menu item is hidden above visible window
            menuEl.scrollTop = menuEl.scrollTop + itemRect.top - 5;
          } else if (itemRect.top > window.innerHeight) {
            // menu item is hidden below visible window
            menuEl.scrollTop = menuEl.scrollTop + (itemRect.top + itemRect.height - window.innerHeight) + 5;
          }
        });
      });

      scope.$watch('ngDisabled', function (newVal) {
        if (newVal === true) wrapperEl.prop('tabIndex', '-1');else if (!scope.useDefault) wrapperEl.prop('tabIndex', '0');
      });
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/forms":20,"../js/lib/jqLite":21,"../js/lib/util":22,"angular":"angular"}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);
/**
 * MUI Angular Tabs Component
 * @module angular/tabs
 */

var moduleName = 'mui.tabs';

_angular2.default.module(moduleName, []).directive('muiTabs', function () {
  return {
    restrict: 'EA',
    transclude: true,
    scope: {
      selectedId: '=?selected',
      onChange: '&?'
    },
    template: '' + '<ul ' + 'class="mui-tabs__bar" ' + 'ng-class=\'{"mui-tabs__bar--justified": justified}\'>' + '<li ' + 'ng-repeat="tab in tabs track by $index" ' + 'ng-class=\'{"mui--is-active": $index === selectedId}\'>' + '<a ng-click="onClick($index)">{{tab.label}}</a>' + '</li>' + '</ul>',
    controller: ['$scope', function ($scope) {
      var counter = 0;

      // init scope
      $scope.tabs = [];

      // add tab
      this.addTab = function (args) {
        // user counter for tab id
        var tabId = counter;
        counter += 1;

        // update tabs list
        $scope.tabs.push({ label: args.label });

        // handle active tabs
        if (args.isActive) $scope.selectedId = tabId;

        // return id
        return tabId;
      };
    }],
    link: function link(scope, element, attrs, ctrl, transcludeFn) {
      var isUndef = _angular2.default.isUndefined;

      // init scope
      if (isUndef(scope.selectedId)) scope.selectedId = 0;
      scope.justified = false;

      // justified
      if (!isUndef(attrs.justified)) scope.justified = true;

      // click handler
      scope.onClick = function (tabId) {
        // check current tab
        if (tabId === scope.selectedId) return;

        // update active tab
        scope.selectedId = tabId;

        // execute onChange callback
        if (scope.onChange) scope.$$postDigest(scope.onChange);
      };

      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
}).directive('muiTab', ['$parse', function ($parse) {
  return {
    require: '^?muiTabs',
    restrict: 'AE',
    scope: {
      active: '&?',
      label: '@?'
    },
    transclude: true,
    template: '<div ' + 'class="mui-tabs__pane" ' + 'ng-class=\'{"mui--is-active": tabId === $parent.selectedId}\'></div>',
    link: function link(scope, element, attrs, ctrl, transcludeFn) {
      var onSelectFn = $parse(attrs.onSelect),
          onDeselectFn = $parse(attrs.onDeselect),
          origScope = scope.$parent.$parent;

      // init scope
      scope.tabId = null;

      // add to parent controller
      if (ctrl) {
        scope.tabId = ctrl.addTab({
          label: scope.label,
          isActive: Boolean(scope.active)
        });
      }

      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.find('div').append(clone);
      });

      scope.$parent.$watch('selectedId', function (newVal, oldVal) {
        // ignore initial load
        if (newVal === oldVal) return;

        // execute onSelect
        if (newVal === scope.tabId) onSelectFn(origScope);

        // execute onDeselect
        if (oldVal === scope.tabId) onDeselectFn(origScope);
      });
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/jqLite":21,"angular":"angular"}],19:[function(require,module,exports){
"use strict";

/**
 * MUI config module
 * @module config
 */

/** Define module API */
module.exports = {
  /** Use debug mode */
  debug: true
};

},{}],20:[function(require,module,exports){
/**
 * MUI CSS/JS form helpers module
 * @module lib/forms.py
 */

'use strict';

var jqLite = require('./jqLite');

/**
 * Menu position/size/scroll helper
 * @returns {Object} Object with keys 'height', 'top', 'scrollTop'
 */
function getMenuPositionalCSSFn(wrapperEl, menuEl, selectedRow) {
  var viewHeight = document.documentElement.clientHeight,
      numRows = menuEl.children.length;

  // determine menu height
  var h = parseInt(menuEl.offsetHeight),
      height = Math.min(h, viewHeight);

  // determine row height
  var p = parseInt(jqLite.css(menuEl, 'padding-top')),
      rowHeight = (h - 2 * p) / numRows;

  // determine 'top'
  var top, initTop, minTop, maxTop;

  initTop = -1 * selectedRow * rowHeight;
  minTop = -1 * wrapperEl.getBoundingClientRect().top;
  maxTop = viewHeight - height + minTop;

  top = Math.min(Math.max(initTop, minTop), maxTop);

  // determine 'scrollTop'
  var scrollTop = 0,
      scrollIdeal,
      scrollMax;

  if (h > viewHeight) {
    scrollIdeal = top + p + selectedRow * rowHeight;
    scrollMax = numRows * rowHeight + 2 * p - height;
    scrollTop = Math.min(scrollIdeal, scrollMax);
  }

  return {
    'height': height + 'px',
    'top': top + 'px',
    'scrollTop': scrollTop
  };
}

/** Define module API */
module.exports = {
  getMenuPositionalCSS: getMenuPositionalCSSFn
};

},{"./jqLite":21}],21:[function(require,module,exports){
/**
 * MUI CSS/JS jqLite module
 * @module lib/jqLite
 */

'use strict';

/**
 * Add a class to an element.
 * @param {Element} element - The DOM element.
 * @param {string} cssClasses - Space separated list of class names.
 */

function jqLiteAddClass(element, cssClasses) {
  if (!cssClasses || !element.setAttribute) return;

  var existingClasses = _getExistingClasses(element),
      splitClasses = cssClasses.split(' '),
      cssClass;

  for (var i = 0; i < splitClasses.length; i++) {
    cssClass = splitClasses[i].trim();
    if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
      existingClasses += cssClass + ' ';
    }
  }

  element.setAttribute('class', existingClasses.trim());
}

/**
 * Get or set CSS properties.
 * @param {Element} element - The DOM element.
 * @param {string} [name] - The property name.
 * @param {string} [value] - The property value.
 */
function jqLiteCss(element, name, value) {
  // Return full style object
  if (name === undefined) {
    return getComputedStyle(element);
  }

  var nameType = jqLiteType(name);

  // Set multiple values
  if (nameType === 'object') {
    for (var key in name) {
      element.style[_camelCase(key)] = name[key];
    }return;
  }

  // Set a single value
  if (nameType === 'string' && value !== undefined) {
    element.style[_camelCase(name)] = value;
  }

  var styleObj = getComputedStyle(element),
      isArray = jqLiteType(name) === 'array';

  // Read single value
  if (!isArray) return _getCurrCssProp(element, name, styleObj);

  // Read multiple values
  var outObj = {},
      key;

  for (var i = 0; i < name.length; i++) {
    key = name[i];
    outObj[key] = _getCurrCssProp(element, key, styleObj);
  }

  return outObj;
}

/**
 * Check if element has class.
 * @param {Element} element - The DOM element.
 * @param {string} cls - The class name string.
 */
function jqLiteHasClass(element, cls) {
  if (!cls || !element.getAttribute) return false;
  return _getExistingClasses(element).indexOf(' ' + cls + ' ') > -1;
}

/**
 * Return the type of a variable.
 * @param {} somevar - The JavaScript variable.
 */
function jqLiteType(somevar) {
  // handle undefined
  if (somevar === undefined) return 'undefined';

  // handle others (of type [object <Type>])
  var typeStr = Object.prototype.toString.call(somevar);
  if (typeStr.indexOf('[object ') === 0) {
    return typeStr.slice(8, -1).toLowerCase();
  } else {
    throw new Error("MUI: Could not understand type: " + typeStr);
  }
}

/**
 * Attach an event handler to a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOn(element, events, callback, useCapture) {
  useCapture = useCapture === undefined ? false : useCapture;

  var cache = element._muiEventCache = element._muiEventCache || {};

  events.split(' ').map(function (event) {
    // add to DOM
    element.addEventListener(event, callback, useCapture);

    // add to cache
    cache[event] = cache[event] || [];
    cache[event].push([callback, useCapture]);
  });
}

/**
 * Remove an event handler from a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOff(element, events, callback, useCapture) {
  useCapture = useCapture === undefined ? false : useCapture;

  // remove from cache
  var cache = element._muiEventCache = element._muiEventCache || {},
      argsList,
      args,
      i;

  events.split(' ').map(function (event) {
    argsList = cache[event] || [];

    i = argsList.length;
    while (i--) {
      args = argsList[i];

      // remove all events if callback is undefined
      if (callback === undefined || args[0] === callback && args[1] === useCapture) {

        // remove from cache
        argsList.splice(i, 1);

        // remove from DOM
        element.removeEventListener(event, args[0], args[1]);
      }
    }
  });
}

/**
 * Attach an event hander which will only execute once per element per event
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOne(element, events, callback, useCapture) {
  events.split(' ').map(function (event) {
    jqLiteOn(element, event, function onFn(ev) {
      // execute callback
      if (callback) callback.apply(this, arguments);

      // remove wrapper
      jqLiteOff(element, event, onFn, useCapture);
    }, useCapture);
  });
}

/**
 * Get or set horizontal scroll position
 * @param {Element} element - The DOM element
 * @param {number} [value] - The scroll position
 */
function jqLiteScrollLeft(element, value) {
  var win = window;

  // get
  if (value === undefined) {
    if (element === win) {
      var docEl = document.documentElement;
      return (win.pageXOffset || docEl.scrollLeft) - (docEl.clientLeft || 0);
    } else {
      return element.scrollLeft;
    }
  }

  // set
  if (element === win) win.scrollTo(value, jqLiteScrollTop(win));else element.scrollLeft = value;
}

/**
 * Get or set vertical scroll position
 * @param {Element} element - The DOM element
 * @param {number} value - The scroll position
 */
function jqLiteScrollTop(element, value) {
  var win = window;

  // get
  if (value === undefined) {
    if (element === win) {
      var docEl = document.documentElement;
      return (win.pageYOffset || docEl.scrollTop) - (docEl.clientTop || 0);
    } else {
      return element.scrollTop;
    }
  }

  // set
  if (element === win) win.scrollTo(jqLiteScrollLeft(win), value);else element.scrollTop = value;
}

/**
 * Return object representing top/left offset and element height/width.
 * @param {Element} element - The DOM element.
 */
function jqLiteOffset(element) {
  var win = window,
      rect = element.getBoundingClientRect(),
      scrollTop = jqLiteScrollTop(win),
      scrollLeft = jqLiteScrollLeft(win);

  return {
    top: rect.top + scrollTop,
    left: rect.left + scrollLeft,
    height: rect.height,
    width: rect.width
  };
}

/**
 * Attach a callback to the DOM ready event listener
 * @param {Function} fn - The callback function.
 */
function jqLiteReady(fn) {
  var done = false,
      top = true,
      doc = document,
      win = doc.defaultView,
      root = doc.documentElement,
      add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
      rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
      pre = doc.addEventListener ? '' : 'on';

  var init = function init(e) {
    if (e.type == 'readystatechange' && doc.readyState != 'complete') {
      return;
    }

    (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
    if (!done && (done = true)) fn.call(win, e.type || e);
  };

  var poll = function poll() {
    try {
      root.doScroll('left');
    } catch (e) {
      setTimeout(poll, 50);return;
    }
    init('poll');
  };

  if (doc.readyState == 'complete') {
    fn.call(win, 'lazy');
  } else {
    if (doc.createEventObject && root.doScroll) {
      try {
        top = !win.frameElement;
      } catch (e) {}
      if (top) poll();
    }
    doc[add](pre + 'DOMContentLoaded', init, false);
    doc[add](pre + 'readystatechange', init, false);
    win[add](pre + 'load', init, false);
  }
}

/**
 * Remove classes from a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} cssClasses - Space separated list of class names.
 */
function jqLiteRemoveClass(element, cssClasses) {
  if (!cssClasses || !element.setAttribute) return;

  var existingClasses = _getExistingClasses(element),
      splitClasses = cssClasses.split(' '),
      cssClass;

  for (var i = 0; i < splitClasses.length; i++) {
    cssClass = splitClasses[i].trim();
    while (existingClasses.indexOf(' ' + cssClass + ' ') >= 0) {
      existingClasses = existingClasses.replace(' ' + cssClass + ' ', ' ');
    }
  }

  element.setAttribute('class', existingClasses.trim());
}

// ------------------------------
// Utilities
// ------------------------------
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g,
    MOZ_HACK_REGEXP = /^moz([A-Z])/,
    ESCAPE_REGEXP = /([.*+?^=!:${}()|\[\]\/\\])/g;

function _getExistingClasses(element) {
  var classes = (element.getAttribute('class') || '').replace(/[\n\t]/g, '');
  return ' ' + classes + ' ';
}

function _camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
}

function _escapeRegExp(string) {
  return string.replace(ESCAPE_REGEXP, "\\$1");
}

function _getCurrCssProp(elem, name, computed) {
  var ret;

  // try computed style
  ret = computed.getPropertyValue(name);

  // try style attribute (if element is not attached to document)
  if (ret === '' && !elem.ownerDocument) ret = elem.style[_camelCase(name)];

  return ret;
}

/**
 * Module API
 */
module.exports = {
  /** Add classes */
  addClass: jqLiteAddClass,

  /** Get or set CSS properties */
  css: jqLiteCss,

  /** Check for class */
  hasClass: jqLiteHasClass,

  /** Remove event handlers */
  off: jqLiteOff,

  /** Return offset values */
  offset: jqLiteOffset,

  /** Add event handlers */
  on: jqLiteOn,

  /** Add an execute-once event handler */
  one: jqLiteOne,

  /** DOM ready event handler */
  ready: jqLiteReady,

  /** Remove classes */
  removeClass: jqLiteRemoveClass,

  /** Check JavaScript variable instance type */
  type: jqLiteType,

  /** Get or set horizontal scroll position */
  scrollLeft: jqLiteScrollLeft,

  /** Get or set vertical scroll position */
  scrollTop: jqLiteScrollTop
};

},{}],22:[function(require,module,exports){
/**
 * MUI CSS/JS utilities module
 * @module lib/util
 */

'use strict';

var config = require('../config'),
    jqLite = require('./jqLite'),
    scrollLock = 0,
    scrollLockCls = 'mui-scroll-lock',
    scrollLockPos,
    scrollStyleEl,
    scrollEventHandler,
    _scrollBarWidth,
    _supportsPointerEvents;

scrollEventHandler = function scrollEventHandler(ev) {
  // stop propagation on window scroll events
  if (!ev.target.tagName) ev.stopImmediatePropagation();
};

/**
 * Logging function
 */
function logFn() {
  var win = window;

  if (config.debug && typeof win.console !== "undefined") {
    try {
      win.console.log.apply(win.console, arguments);
    } catch (a) {
      var e = Array.prototype.slice.call(arguments);
      win.console.log(e.join("\n"));
    }
  }
}

/**
 * Load CSS text in new stylesheet
 * @param {string} cssText - The css text.
 */
function loadStyleFn(cssText) {
  var doc = document,
      head;

  // copied from jQuery 
  head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;

  var e = doc.createElement('style');
  e.type = 'text/css';

  if (e.styleSheet) e.styleSheet.cssText = cssText;else e.appendChild(doc.createTextNode(cssText));

  // add to document
  head.insertBefore(e, head.firstChild);

  return e;
}

/**
 * Raise an error
 * @param {string} msg - The error message.
 */
function raiseErrorFn(msg, useConsole) {
  if (useConsole) {
    if (typeof console !== 'undefined') console.warn('MUI Warning: ' + msg);
  } else {
    throw new Error('MUI: ' + msg);
  }
}

/**
 * Convert Classname object, with class as key and true/false as value, to an
 * class string.
 * @param  {Object} classes The classes
 * @return {String}         class string
 */
function classNamesFn(classes) {
  var cs = '';
  for (var i in classes) {
    cs += classes[i] ? i + ' ' : '';
  }
  return cs.trim();
}

/**
 * Check if client supports pointer events.
 */
function supportsPointerEventsFn() {
  // check cache
  if (_supportsPointerEvents !== undefined) return _supportsPointerEvents;

  var element = document.createElement('x');
  element.style.cssText = 'pointer-events:auto';
  _supportsPointerEvents = element.style.pointerEvents === 'auto';
  return _supportsPointerEvents;
}

/**
 * Create callback closure.
 * @param {Object} instance - The object instance.
 * @param {String} funcName - The name of the callback function.
 */
function callbackFn(instance, funcName) {
  return function () {
    instance[funcName].apply(instance, arguments);
  };
}

/**
 * Dispatch event.
 * @param {Element} element - The DOM element.
 * @param {String} eventType - The event type.
 * @param {Boolean} bubbles=true - If true, event bubbles.
 * @param {Boolean} cancelable=true = If true, event is cancelable
 * @param {Object} [data] - Data to add to event object
 */
function dispatchEventFn(element, eventType, bubbles, cancelable, data) {
  var ev = document.createEvent('HTMLEvents'),
      bubbles = bubbles !== undefined ? bubbles : true,
      cancelable = cancelable !== undefined ? cancelable : true,
      k;

  ev.initEvent(eventType, bubbles, cancelable);

  // add data to event object
  if (data) for (k in data) {
    ev[k] = data[k];
  } // dispatch
  if (element) element.dispatchEvent(ev);

  return ev;
}

/**
 * Turn on window scroll lock.
 */
function enableScrollLockFn() {
  // increment counter
  scrollLock += 1;

  // add lock
  if (scrollLock === 1) {
    var doc = document,
        win = window,
        htmlEl = doc.documentElement,
        bodyEl = doc.body,
        scrollBarWidth = getScrollBarWidth(),
        cssProps,
        cssStr,
        x;

    // define scroll lock class dynamically
    cssProps = ['overflow:hidden'];

    if (scrollBarWidth) {
      // scrollbar-y
      if (htmlEl.scrollHeight > htmlEl.clientHeight) {
        x = parseInt(jqLite.css(bodyEl, 'padding-right')) + scrollBarWidth;
        cssProps.push('padding-right:' + x + 'px');
      }

      // scrollbar-x
      if (htmlEl.scrollWidth > htmlEl.clientWidth) {
        x = parseInt(jqLite.css(bodyEl, 'padding-bottom')) + scrollBarWidth;
        cssProps.push('padding-bottom:' + x + 'px');
      }
    }

    // define css class dynamically
    cssStr = '.' + scrollLockCls + '{';
    cssStr += cssProps.join(' !important;') + ' !important;}';
    scrollStyleEl = loadStyleFn(cssStr);

    // cancel 'scroll' event listener callbacks
    jqLite.on(win, 'scroll', scrollEventHandler, true);

    // add scroll lock
    scrollLockPos = { left: jqLite.scrollLeft(win), top: jqLite.scrollTop(win) };
    jqLite.addClass(bodyEl, scrollLockCls);
  }
}

/**
 * Turn off window scroll lock.
 * @param {Boolean} resetPos - Reset scroll position to original value.
 */
function disableScrollLockFn(resetPos) {
  // ignore
  if (scrollLock === 0) return;

  // decrement counter
  scrollLock -= 1;

  // remove lock 
  if (scrollLock === 0) {
    // remove scroll lock and delete style element
    jqLite.removeClass(document.body, scrollLockCls);

    // restore scroll position
    if (resetPos) window.scrollTo(scrollLockPos.left, scrollLockPos.top);

    // restore scroll event listeners
    jqLite.off(window, 'scroll', scrollEventHandler, true);

    // delete style element (deferred for Firefox Quantum bugfix)
    setTimeout(function () {
      scrollStyleEl.parentNode.removeChild(scrollStyleEl);
    }, 0);
  }
}

/**
 * Return scroll bar width.
 */
var getScrollBarWidth = function getScrollBarWidth() {
  // check cache
  if (_scrollBarWidth !== undefined) return _scrollBarWidth;

  // calculate scroll bar width
  var doc = document,
      bodyEl = doc.body,
      el = doc.createElement('div');

  el.innerHTML = '<div style="width:50px;height:50px;position:absolute;' + 'left:-50px;top:-50px;overflow:auto;"><div style="width:1px;' + 'height:100px;"></div></div>';
  el = el.firstChild;
  bodyEl.appendChild(el);
  _scrollBarWidth = el.offsetWidth - el.clientWidth;
  bodyEl.removeChild(el);

  return _scrollBarWidth;
};

/**
 * requestAnimationFrame polyfilled
 * @param {Function} callback - The callback function
 */
function requestAnimationFrameFn(callback) {
  var fn = window.requestAnimationFrame;
  if (fn) fn(callback);else setTimeout(callback, 0);
}

/**
 * Define the module API
 */
module.exports = {
  /** Create callback closures */
  callback: callbackFn,

  /** Classnames object to string */
  classNames: classNamesFn,

  /** Disable scroll lock */
  disableScrollLock: disableScrollLockFn,

  /** Dispatch event */
  dispatchEvent: dispatchEventFn,

  /** Enable scroll lock */
  enableScrollLock: enableScrollLockFn,

  /** Log messages to the console when debug is turned on */
  log: logFn,

  /** Load CSS text as new stylesheet */
  loadStyle: loadStyleFn,

  /** Raise MUI error */
  raiseError: raiseErrorFn,

  /** Request animation frame */
  requestAnimationFrame: requestAnimationFrameFn,

  /** Support Pointer Events check */
  supportsPointerEvents: supportsPointerEventsFn
};

},{"../config":19,"./jqLite":21}]},{},[1]);
